<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ridge vs OLS Regression</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Load Babel for JSX support in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    </style>
</head>
<body class="bg-slate-950 text-slate-200 min-h-screen flex flex-col items-center justify-center">

    <div id="root" class="w-full h-full flex items-center justify-center p-4"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;

        // --- Linear Algebra Engine ---

        const zeros = (rows, cols) => Array(rows).fill(0).map(() => Array(cols).fill(0));

        const transpose = (matrix) => {
            return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
        };

        const multiply = (A, B) => {
            const result = zeros(A.length, B[0].length);
            for (let r = 0; r < A.length; r++) {
                for (let c = 0; c < B[0].length; c++) {
                    let sum = 0;
                    for (let k = 0; k < A[0].length; k++) {
                        sum += A[r][k] * B[k][c];
                    }
                    result[r][c] = sum;
                }
            }
            return result;
        };

        const add = (A, B) => {
            return A.map((row, r) => row.map((val, c) => val + B[r][c]));
        };

        const identity = (size, scalar = 1) => {
            const res = zeros(size, size);
            for (let i = 0; i < size; i++) res[i][i] = scalar;
            return res;
        };

        // Robust Gaussian Elimination Solver
        const solveLinearSystem = (A, b) => {
            const n = A.length;
            // Deep copy
            const M = A.map((row, i) => [...row, b[i][0]]); 

            for (let i = 0; i < n; i++) {
                // Pivot selection
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;
                }
                
                // Swap rows
                [M[i], M[maxRow]] = [M[maxRow], M[i]];

                // Check for singular matrix (pivot is too close to zero)
                if (Math.abs(M[i][i]) < 1e-10) {
                    // If singular, return zeros to avoid crash
                    return Array(n).fill([0]);
                }

                // Eliminate
                for (let k = i + 1; k < n; k++) {
                    const factor = M[k][i] / M[i][i];
                    for (let j = i; j <= n; j++) {
                        M[k][j] -= factor * M[i][j];
                    }
                }
            }

            // Back Substitution
            const x = Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) {
                    sum += M[i][j] * x[j];
                }
                x[i] = (M[i][n] - sum) / M[i][i];
            }
            
            return x.map(val => [val]); 
        };

        // --- Feature Engineering ---
        const normalizeX = (x) => (x - 3.25) / 1.8; 

        const expandFeatures = (xValues, degree) => {
            return xValues.map(x => {
                const scaledX = normalizeX(x);
                const row = [];
                for (let d = 0; d <= degree; d++) {
                    row.push(Math.pow(scaledX, d));
                }
                return row;
            });
        };

        const predict = (X, w) => {
            if (!w || w.length === 0) return Array(X.length).fill(0);
            return multiply(X, w).map(row => row[0]);
        };

        // --- Main Component ---
        const RidgeOLS = () => {
            // Configuration
            const DEGREE = 12; 
            const X_MIN = 0;
            const X_MAX = 6.5;
            const Y_MIN = -3;
            const Y_MAX = 3;
            
            // State
            const [noiseLevel, setNoiseLevel] = useState(1.0);
            const [alpha, setAlpha] = useState(2.0);
            const [baseData, setBaseData] = useState([]);
            
            const trueFunction = useCallback((x) => {
                return Math.sin(x) + 0.5 * Math.cos(2 * x);
            }, []);

            // Generate Base Data
            const generateBaseData = useCallback(() => {
                const points = [];
                const numPoints = 18; 
                for (let i = 0; i < numPoints; i++) {
                    const x = (X_MAX - X_MIN) * (i / (numPoints - 1)) + (Math.random() - 0.5) * 0.25;
                    const trueY = trueFunction(x);
                    const rawNoise = (Math.random() - 0.5) * 2; 
                    points.push({ x, trueY, rawNoise });
                }
                setBaseData(points);
            }, [trueFunction]);

            useEffect(() => {
                generateBaseData();
            }, [generateBaseData]);

            // Derived Data
            const dataPoints = useMemo(() => {
                return baseData.map(p => ({
                    x: p.x,
                    y: p.trueY + (p.rawNoise * noiseLevel)
                }));
            }, [baseData, noiseLevel]);

            // --- Regression Solver ---
            const { olsCurve, ridgeCurve, trueCurve } = useMemo(() => {
                if (dataPoints.length === 0) return { olsCurve: [], ridgeCurve: [], trueCurve: [] };

                const xVals = dataPoints.map(p => p.x);
                const yVals = dataPoints.map(p => [p.y]); 

                // 1. Design Matrix
                const X = expandFeatures(xVals, DEGREE);
                const XT = transpose(X);
                const XTX = multiply(XT, X);
                const XTy = multiply(XT, yVals);

                // 2. OLS Solution
                const I_ols = identity(DEGREE + 1, 1e-4); 
                const A_ols = add(XTX, I_ols); 
                const w_ols = solveLinearSystem(A_ols, XTy);

                // 3. Ridge Solution
                const alphaMultiplier = 10.0; 
                const effectiveAlpha = alpha * alphaMultiplier;
                const I_ridge = identity(DEGREE + 1, effectiveAlpha);
                I_ridge[0][0] = 0; 
                const A_ridge = add(XTX, I_ridge);
                const w_ridge = solveLinearSystem(A_ridge, XTy);

                // 4. Generate Plotting Points
                const plotPoints = [];
                const steps = 150;
                for (let i = 0; i <= steps; i++) {
                    const x = X_MIN + (X_MAX - X_MIN) * (i / steps);
                    const feat = expandFeatures([x], DEGREE);
                    const y_ols = predict(feat, w_ols)[0];
                    const y_ridge = predict(feat, w_ridge)[0];
                    const y_true = trueFunction(x);

                    const clamp = (v) => Math.max(Y_MIN - 2, Math.min(Y_MAX + 2, v));
                    plotPoints.push({ 
                        x, 
                        y_ols: clamp(y_ols), 
                        y_ridge: clamp(y_ridge), 
                        y_true: clamp(y_true) 
                    });
                }

                return { olsCurve: plotPoints, ridgeCurve: plotPoints, trueCurve: plotPoints };
            }, [dataPoints, alpha, trueFunction]);

            // --- Visualization Helpers ---
            const width = 800;
            const height = 400;
            const padding = 40;

            const scaleX = (x) => padding + ((x - X_MIN) / (X_MAX - X_MIN)) * (width - 2 * padding);
            const scaleY = (y) => height - padding - ((y - Y_MIN) / (Y_MAX - Y_MIN)) * (height - 2 * padding);

            const createPath = (data, key) => {
                const validData = data.filter(p => !isNaN(p[key]));
                if (validData.length === 0) return "";
                return validData.map((p, i) => 
                    `${i === 0 ? 'M' : 'L'} ${scaleX(p.x)} ${scaleY(p[key])}`
                ).join(' ');
            };

            return (
                <div className="w-full max-w-4xl bg-slate-900/80 backdrop-blur-sm rounded-xl border border-slate-800 shadow-2xl overflow-hidden">
                    <div className="p-6 border-b border-slate-800 flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
                        <div>
                            <h1 className="text-2xl font-bold text-white">Ridge vs. OLS Regression</h1>
                            <p className="text-slate-400 text-sm mt-1">Degree {DEGREE} Polynomial Fit</p>
                        </div>
                        <div className="text-right hidden md:block">
                            <div className="text-sm font-mono text-green-400">Alpha = {alpha.toFixed(1)}</div>
                            <div className="text-xs text-slate-500">Regularization Strength</div>
                        </div>
                    </div>

                    <div className="relative w-full h-[450px] bg-slate-900 p-4 select-none">
                        <div className="absolute top-6 left-16 md:left-20 bg-slate-950/90 border border-slate-800 p-3 rounded-lg text-xs z-10 shadow-lg pointer-events-none">
                            <div className="flex items-center gap-2 mb-1">
                                <span className="w-3 h-3 rounded-full bg-blue-500"></span>
                                <span className="text-slate-300">Data Points</span>
                            </div>
                            <div className="flex items-center gap-2 mb-1">
                                <span className="w-8 h-0.5 border-t-2 border-dashed border-slate-500"></span>
                                <span className="text-slate-400">True Function</span>
                            </div>
                            <div className="flex items-center gap-2 mb-1">
                                <span className="w-8 h-1 bg-red-400 rounded-full"></span>
                                <span className="text-red-300 font-medium">OLS (No Penalty)</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <span className="w-8 h-1 bg-green-400 rounded-full"></span>
                                <span className="text-green-300 font-medium">Ridge (Regularized)</span>
                            </div>
                        </div>

                        <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-full overflow-hidden rounded-lg bg-slate-900/50">
                            {[...Array(11)].map((_, i) => {
                                const val = Y_MIN + (Y_MAX - Y_MIN) * (i / 10);
                                const y = scaleY(val);
                                return (
                                    <g key={`grid-y-${i}`}>
                                        <line x1={padding} y1={y} x2={width - padding} y2={y} stroke="#334155" strokeWidth="1" opacity="0.3" />
                                        <text x={padding - 10} y={y + 4} fill="#64748b" fontSize="12" textAnchor="end">{val.toFixed(1)}</text>
                                    </g>
                                );
                            })}
                            {[...Array(7)].map((_, i) => {
                                const val = i;
                                const x = scaleX(val);
                                return (
                                    <g key={`grid-x-${i}`}>
                                        <line x1={x} y1={height - padding} x2={x} y2={padding} stroke="#334155" strokeWidth="1" opacity="0.3" />
                                        <text x={x} y={height - padding + 20} fill="#64748b" fontSize="12" textAnchor="middle">{val}</text>
                                    </g>
                                );
                            })}

                            <text x={width - padding + 20} y={height - padding + 5} fill="#94a3b8" fontSize="14" fontWeight="bold">x →</text>
                            <text x={padding} y={padding - 20} fill="#94a3b8" fontSize="14" fontWeight="bold">↑ y</text>

                            <path d={createPath(trueCurve, 'y_true')} fill="none" stroke="#64748b" strokeWidth="2" strokeDasharray="5,5" className="opacity-50" />
                            <path d={createPath(olsCurve, 'y_ols')} fill="none" stroke="#f87171" strokeWidth="3" strokeLinecap="round" className="filter drop-shadow-md opacity-90" />
                            <path d={createPath(ridgeCurve, 'y_ridge')} fill="none" stroke="#4ade80" strokeWidth="4" strokeLinecap="round" className="filter drop-shadow-lg transition-all duration-300" />

                            {dataPoints.map((p, i) => (
                                <circle key={i} cx={scaleX(p.x)} cy={scaleY(p.y)} r="5" fill="#3b82f6" stroke="#1e293b" strokeWidth="2" className="hover:r-7 transition-all duration-200" >
                                    <title>({p.x.toFixed(2)}, {p.y.toFixed(2)})</title>
                                </circle>
                            ))}
                        </svg>
                    </div>

                    <div className="bg-slate-900 p-6 md:p-8 border-t border-slate-800 grid grid-cols-1 md:grid-cols-2 gap-8 md:gap-12">
                        <div className="space-y-6">
                            <div>
                                <div className="flex justify-between mb-2">
                                    <label className="text-slate-300 font-semibold">Noise Level</label>
                                    <span className="text-blue-400 font-mono">{noiseLevel.toFixed(2)}</span>
                                </div>
                                <input type="range" min="0" max="3" step="0.05" value={noiseLevel} onChange={(e) => setNoiseLevel(parseFloat(e.target.value))} className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500 hover:accent-blue-400" />
                                <p className="text-xs text-slate-500 mt-2">Higher noise makes OLS wiggle more uncontrollably.</p>
                            </div>
                            <button onClick={generateBaseData} className="px-6 py-3 bg-slate-700 hover:bg-slate-600 text-white font-semibold rounded-full transition-all duration-200 shadow-lg active:scale-95 flex items-center justify-center gap-2 w-full">Generate New Data</button>
                        </div>

                        <div className="space-y-6">
                            <div>
                                <div className="flex justify-between mb-2">
                                    <label className="text-slate-300 font-semibold">Regularization (Alpha)</label>
                                    <span className="text-blue-400 font-mono">{alpha.toFixed(1)}</span>
                                </div>
                                <input type="range" min="0" max="20" step="0.1" value={alpha} onChange={(e) => setAlpha(parseFloat(e.target.value))} className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500 hover:accent-blue-400" />
                                <p className="text-xs text-slate-500 mt-2">Slide right to smooth out the green curve (Ridge).<br/>Slide left (0) to match the red curve (OLS).</p>
                            </div>
                            <button onClick={() => { setAlpha(2.0); setNoiseLevel(1.0); generateBaseData(); }} className="px-6 py-3 bg-blue-600 hover:bg-blue-500 text-white font-semibold rounded-full transition-all duration-200 shadow-lg shadow-blue-900/50 active:scale-95 w-full">Reset Simulation</button>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<RidgeOLS />);
    </script>
</body>
</html>